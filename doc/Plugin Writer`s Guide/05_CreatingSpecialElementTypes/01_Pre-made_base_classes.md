# 一、Pre-made base classes

到目前为止，我们一直在探讨创建任何类型的GStreamer元素的低级概念。现在，让我们假设您只想创建一个与“esdsink”等完全相同的简单音频接收器，或者一个仅对音频音量进行标准化的滤波器。这些元素在概念上非常通用，因为它们没有特殊操作，所以编写它们应该比提供自己的调度程序激活函数和执行复杂的caps协商要容易。出于这个目的，GStreamer提供了简化某些元素类型的基类。这些基类将在本章中讨论。

## 1 Writing a sink

接收器在GStreamer中是特殊的元素。这是因为接收器元素必须处理preroll，这是一个过程，确保进入GST_STATE_PAUSED状态的元素在状态变更后具备已准备好的缓冲区。其结果是，这种元素可以在进入GST_STATE_PLAYING状态后立即开始处理数据，无需等待一段时间来初始化输出或设置解码器；所有这些都已在成功完成状态更改为GST_STATE_PAUSED之前完成。

然而，preroll是一个复杂的过程，会在许多元素中需要相同的代码。因此，接收器元素可以从GstBaseSink基类派生，该基类自动执行preroll和一些其他实用函数。派生类只需实现一些虚拟函数，就可以自动工作。

基类实现了接收器必须执行的大部分同步逻辑。

但是，GstBaseSink基类对元素有一些限制：

- 它要求接收器只有一个接收端口。需要多个接收端口的接收器元素必须创建一个包含多个GstBaseSink元素的管理器元素。

接收器元素可以使用通常的GObject方便宏G_DEFINE_TYPE()从GstBaseSink派生：

```c
G_DEFINE_TYPE (GstMySink, gst_my_sink, GST_TYPE_BASE_SINK);

[..]

static void
gst_my_sink_class_init (GstMySinkClass * klass)
{
  klass->set_caps = [..];
  klass->render = [..];
[..]
}
```

从GstBaseSink派生的优点很多：

- 派生实现几乎不需要了解preroll，也不需要了解preroll的技术实现要求。基类会处理所有繁重的工作。

- 在派生类中需要编写的代码更少，代码是共享的（因此也是共享的错误修复）。

还有一些专门用于音频和视频的基类，让我们稍微了解一下。

### 1.1 Writing an audio sink

基本上，音频输出实现只是一般输出的特殊情况。音频输出增加了播放样本的调度复杂性。它必须将管道中选择的时钟与音频设备的时钟进行匹配，并计算并补偿漂移和抖动。

有两个音频基类可供选择，具体取决于您的需求：GstAudioBasesink和GstAudioSink。音频基类sink提供了如何处理同步和调度的完全控制，通过使用派生类控制和提供的环形缓冲区。音频输出基类是音频基类sink的派生类，实现了默认同步的标准环形缓冲区和标准音频样本时钟。这个基类的派生类只需要提供_open()、_close()和_write()函数实现，以及一些可选函数。这对于许多音频服务器输出元素甚至大多数接口来说应该足够了。需要更高要求的音频系统，例如Jack，可能会希望实现GstAudioBaseSink基类。

GstAudioBaseSink几乎没有限制，几乎适合每个实现，但难以实现。另一方面，GstAudioSink只适用于具有简单open() / close() / write() API的系统（实际上几乎包括所有系统），但它的优势在于更容易实现。第二个基类的好处很大：

- 自动同步，派生类中无需任何代码。

- 还会自动提供一个时钟，以便其他输出元素（例如在音频/视频播放的情况下）同步。

- 可以通过在基类中进行更改来向所有音频输出添加功能，这使得维护变得容易。

- 派生类只需要三个小函数，以及一些GObject样板代码。

除了实现音频基类的虚拟函数外，派生类还可以（应该）实现用于协商的GstBaseSink set_caps()和get_caps()虚拟函数。

### 1.2 Writing a video sink

创建一个视频输出元素可以使用GstVideoSink基类，它在内部派生自GstBaseSink。目前，它还没有实现任何功能，但会添加另一个编译依赖项，因此派生类需要实现所有基础sink虚拟函数。当它们正确地执行这些函数时，这将对视频输出的最终用户体验产生一些积极影响：

- 由于预滚动（和预滚动()虚拟函数），在进入GST_STATE_PAUSED状态时，可以显示视频帧。

- 通过向GstVideoSink添加新功能，可以为所有视频输出元素添加扩展，这些扩展影响所有视频输出元素，但只需要编写一次，这是一个巨大的维护优势。

## 2 Writing a source

在前面的部分中，特别是在“提供随机访问”部分，我们已经了解到某些类型的元素可以提供随机访问。这显然适用于从随机可寻址位置读取的源元素，比如文件源。然而，其他源元素可能更适合描述为实时源元素，比如摄像头源、音频卡源等；这些源元素不可寻址，不提供字节精确访问。对于所有这些用例，GStreamer提供了两个基类：GstBaseSrc用于基本的源功能，GstPushSrc用于非字节精确源基类。pushsource基类本身也从basesource派生，因此basesource的所有说明也适用于pushsource。

basesrc类为派生类自动执行了一些操作，因此它们不再需要担心这些问题：

- 修复了GstBaseSrc的问题，自动适用于所有派生类。

- 自动的源垫激活处理，以及在我们被分配启动任务的情况下进行任务包装。

然而，GstBaseSrc可能不适用于所有情况；它有一些限制：

- 只有一个源垫。需要多个源垫的源元素必须在内部实现一个管理垫和使用多个源元素，或者制作一个使用源元素和解复用器的管理元素。

可以使用特殊的内存，如X服务器内存指针或通过mmap()映射的内存区域，作为从create()虚拟函数返回的缓冲区中的数据指针。

### 2.1 Writing an audio source

音频源实际上只是pushsource的一个特殊情况。音频源可以是任何读取音频的东西，比如从声音服务器读取的源、内核接口（比如ALSA）或测试声音/信号发生器。GStreamer提供了两个基类，类似于写音频接收器中描述的两个音频接收器；一个基于ringbuffer，要求派生类自己处理调度、同步等。另一个基于GstAudioBaseSrc，称为GstAudioSrc，提供了一个简单的open()、close()和read()接口，非常容易实现，对于大多数音频源和音频接口（例如ALSA或OSS）来说足够了。

GstAudioSrc基类对派生类有很多好处，除了基于的GstPushSrc基类的好处：

- 执行同步并提供时钟。

- 可以向其添加新功能，将自动应用于所有派生类。

## 3 Writing a transformation element

第三个GStreamer提供的基类是GstBaseTransform。这是一个基类，用于具有一个源pad和一个接收pad的元素，这些元素充当某种过滤器，例如音量更改、音频重采样、音频格式转换等等。这种元素需要进行相当多的簿记工作，以确保缓冲区分配转发、直通、原地处理等等都能正常工作。这个基类为你处理了所有这些，因此你只需要进行实际处理。

由于GstBaseTransform基于过滤器的1对1模型，它可能不适用于需要从流中解析属性的元素，例如解码器。此外，它也不适用于需要多个源pad或接收pad的元素。