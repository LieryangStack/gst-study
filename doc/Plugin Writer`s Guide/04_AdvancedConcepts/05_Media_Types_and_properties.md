# 5 Media Types and Properties

有很多可能的媒体类型，用于在元素之间传递数据。实际上，每个新定义的元素都可以使用新的数据格式（尽管除非至少有另一个元素识别该格式，否则它将无用，因为没有任何东西可以与其链接）。

为了媒体类型能够有用，以及使自动插件系统等系统正常运行，有必要让所有元素就媒体类型的定义以及每种媒体类型所需的属性达成一致。GStreamer 框架本身只提供了定义媒体类型和参数的能力，但不固定媒体类型和参数的含义，也不强制新媒体类型的创建遵循某种标准。这是一个需要政策决定的事情，而不是技术系统来强制执行。

目前，政策很简单：

- 如果可以使用已经存在的媒体类型，不要创建新的媒体类型。

- 如果要创建新的媒体类型，首先与其他 GStreamer 开发人员讨论，可以通过 IRC、邮件列表等方式进行讨论。

- 尽量确保新格式的名称不会与已经存在的内容冲突，并且不要使用比实际需要更通用的名称。例如，"audio/compressed" 是一个太过通用的名称，不能很好地表示使用 mp3 编解码的音频数据。相反，"audio/mp3" 可能是一个合适的名称，或者 "audio/compressed" 可以存在，但要有一个属性来指示使用的压缩类型。

- 确保当你创建新的媒体类型时，要清晰地定义它，并将其添加到已知媒体类型的列表中，以便其他开发人员在编写自己的元素时能够正确使用这种媒体类型。

## 1 Building a Simple Format for Testing

如果你需要一种尚未在我们的已定义类型列表中定义的新格式，那么你可能需要一些有关媒体类型命名、属性等方面的一般准则。一个理想的媒体类型应当等同于由 IANA 定义的媒体类型，否则，它应采用 type/x-name 的形式，其中 type 表示这种媒体类型处理的数据类型（音频、视频等），而 name 应该是特定于这个特定类型的内容。音频和视频媒体类型应尽量支持通用的音频/视频属性（List of Defined Types），并可以使用自己的属性。要了解我们认为哪些属性有用的想法，可以再次查看列表。

花时间找到适合你的类型的属性集。没有必要着急。此外，进行实验通常是一个不错的主意。经验表明，理论上构思出来的类型通常是好的，但它们仍然需要实际使用来确保它们满足需求。确保你的属性名称不与其他类型中使用的类似属性发生冲突。如果它们匹配，确保它们具有相同的含义；不允许使用相同名称但具有不同类型的属性。

## 2 Typefind Functions and Autoplugging

## 3 List of Defined Types