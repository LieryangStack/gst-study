# 7 Clocking

在处理复杂的媒体时，需要按照特定的顺序和时间播放每个声音和视频样本。为了实现这一目的，GStreamer 提供了一种同步机制。

## 1 Clocks

在 GStreamer 中，时间是由特定的 GstClock 对象的 gst_clock_get_time() 方法返回的值来定义的。

在典型的计算机中，有许多可以用作时间源的来源，例如系统时间、声卡、CPU 性能计数器等。因此，GStreamer 中提供了许多不同的 GstClock 实现。时钟时间并不总是从0或某个已知值开始计数。一些时钟从某个已知的起始日期开始计数，其他时钟则从上次重启以来开始计数，等等...

由于时钟返回的是绝对时间的度量，它们通常不会直接使用。而是使用两个时钟时间之间的差异来测量根据某个时钟的经过时间。

## 2 Clock running-time

时钟使用 gst_clock_get_time() 返回相对于该时钟的绝对时间。从绝对时间计算出了运行时间，它就是绝对时间与先前快照的绝对时间，称为基准时间（base-time），之间的差值。因此：

运行时间 = 绝对时间 - 基准时间

GStreamer 的 GstPipeline 对象在转换到 PLAYING 状态时会维护一个 GstClock 对象和一个基准时间（base-time）。管道将为管道中的每个元素选择一个 GstClock 句柄，并分配选择的基准时间。管道将选择一个基准时间，以便运行时间反映在 PLAYING 状态下的总时间。因此，当管道处于 PAUSED 状态时，运行时间会暂停。

由于管道中的所有对象都具有相同的时钟和基准时间，它们都可以根据管道时钟计算运行时间。

## 3 Buffer running-time

要计算缓冲区的运行时间，我们需要一个缓冲区时间戳和在缓冲区之前的 SEGMENT 事件。首先，我们可以将 SEGMENT 事件转换为一个 GstSegment 对象，然后我们可以使用 gst_segment_to_running_time() 函数来计算缓冲区的运行时间。

现在，同步的关键是确保当时钟达到相同的运行时间时，播放具有特定运行时间的缓冲区。通常，这项任务由接收器元素（sink elements）完成。接收器还必须考虑管道中配置的延迟，并在与管道时钟同步之前将其添加到缓冲区的运行时间中。

## 4 Obligations of each element

GStreamer与管道中的每个元素之间的规定如下：

### 4.1 非实时源元素（Non-live source elements）
非实时源元素必须在它们交付的每个缓冲区中放置一个时间戳，如果可能的话。它们必须选择时间戳和 SEGMENT 事件的值，以便缓冲区的运行时间从0开始。

某些源（例如filesrc）无法在所有缓冲区上生成时间戳。但是，它们可以在第一个缓冲区上创建一个时间戳（运行时间为0）。

然后，源会推送 SEGMENT 事件，然后是带有时间戳的缓冲区。

### 4.2 实时源元素（Live source elements）
实时源元素必须在它们传送的每个缓冲区中放置一个时间戳。它们必须以这样的方式选择时间戳和 SEGMENT 事件的值，以便缓冲区的运行时间与捕获缓冲区中的第一个字节时的管道时钟的运行时间完全匹配。

### 4.3 解析器/解码器/编码器元素（Parser/Decoder/Encoder elements）
解析器/解码器元素必须使用传入的时间戳并将其传递到生成的输出缓冲区中。当可能时，它们允许在缺失的输入缓冲区上进行插值或重构时间戳。

### 4.4 解复用器元素（Demuxer elements）
解复用器元素通常可以将存储在媒体文件中的时间戳设置到传出的缓冲区中。它们需要确保在相同时播放的传出缓冲区具有相同的运行时间。解复用器还需要考虑缓冲区上的传入时间戳，并使用它来计算传出缓冲区时间戳的偏移。

### 4.5 复用器元素（Muxer elements）
复用器元素应使用传入缓冲区的运行时间来复用不同的流。它们应将传入的运行时间复制到传出的缓冲区中。

### 4.6 接收器元素（Sink elements）
如果元素旨在在特定时间（实时播放）发出样本，则元素应该需要一个时钟，因此实现 set_clock 方法。

然后，接收器应确保具有运行时间的样本在管道时钟达到该运行时间 + 延迟时播放。一些元素可能会使用时钟API，如gst_clock_id_wait() 来执行此操作。其他接收器可能需要使用其他方式来安排及时播放数据。